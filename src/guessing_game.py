'''
The Guessing Game.

This game is contrived, but the point is to simplify the definition of game to
the point that reasoning about what IID data means is very simple. This also
fits in nicely with reasoning about neural networks based on the UAT.

Each instance of the game is a function generating answers, then filled with
noise. Normally you would only show correct answers and fit the network. In an
RL environment, the 'correct' answers are obscured and often difficult to find.
To simulate this, the correct answers are literally obscured by noise, and the
reward is hard to find: You only get it at the end of the game. This is
essentially the normal approximation problem, but embedded in a noisier space.

More importantly, each instance of the game constitutes its own distribution. 
We can easily think about these instances as being similar to 'labels' in e.x.
MNIST. Having a few instances would cause a normal network to learn to recognize
a few different functions.
'''
import random

class Game():
    '''
        An instance of the guessing game with k levels with n possible answers
        (including the correct one) at each level. The correct answers are
        generated by the function f(level_number).

        At each timestep, the agent must find the correct answer from a list of
        possible answers. Solving this is known as a 'level'.

        Ex: 
        ```
        # 4 possible answers per level, 5 levels, [0,10] range for possible 
        # answers, correct answer is 0-indexed level number.
        Game(4, 5, 0, 10, lambda x: x)
        ```
    '''
    def __init__(self, actions, levels, min_possible_answer, max_possible_answer, correct_answer):
        self.instance = Game.instance(actions, levels, min_possible_answer, max_possible_answer, correct_answer)
        self.correct_answer = correct_answer
        self.current_level = 0
        self.max_level = levels
    
    def add_answer(l, a):
        l.append(a)
        random.shuffle(l)
        return l

    def instance(n, k, min_possible_answer, max_possible_answer, f):
        l = []
        l.extend(Game.add_answer([random.randint(min_possible_answer, max_possible_answer) for _ in range(0,n-1)], f(j)) for j in range(1,k+1))
        return l

    def current_state(self):
        return self.instance[self.current_level]

    def guess(self, guess):
        if guess == self.correct_answer(self.current_level):
            if self.current_level+1 == self.max_level:
                return (True, self.instance[self.current_level-1])
            else:
                self.current_level += 1
                return (False, self.instance[self.current_level])
        else:
            return (False, self.instance[self.current_level])

